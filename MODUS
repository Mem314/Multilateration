import matplotlib.pyplot as plt
import matplotlib.tri
from matplotlib import cm
import numpy as np
import random
import sympy as sy
import math
from trilateration import sphereCircle, Trilateration_3D
from matplotlib.animation import FuncAnimation

The_Sierpinski_Triangle = True
length = 30

fig = plt.figure()
ax = fig.add_subplot()
max_width = max(0, length)
ax.set_ylim((0, max_width))
ax.set_xlim((0, max_width))
#ax.plot((-max_width + 1, max_width - 1), (0, 0), (0, 0), 'r', label='x-axis')
#ax.plot((0, 0), (-max_width + 1, max_width - 1), (0, 0), 'k', label='y-axis')

class Points:
    def __init__(self, x, y, color):
        self.x = x
        self.y = y
        self.color = color

    def coord(self):
        return self.x, self.y
    def plot_points(self):
        plot = plt.plot(self.x, self.y, marker=".", color=self.color)
        return plot

p =  length
point_1 = Points(1,1, "red")
point_2 = Points(p-1,1, "red")
point_3 = Points(p/2, p-1, "red")
point_1.plot_points()
point_2.plot_points()
point_3.plot_points()

num_points = np.array(range(1, 10))

a0 = p-1  # upper bound
b0 = 1    # lower bound

#first_point = ((np.random.rand(num_points, 2)) * (b-a)) + a

def first_point(p1, p2, p3):
    """
    Random first point on the triangle with vertices p1, p2 and p3.
    """
    x, y = sorted([random.random(), random.random()])
    s, t, u = x, y - x, 1 - y
    return (s * p1[0] + t * p2[0] + u * p3[0],
            s * p1[1] + t * p2[1] + u * p3[1])
p1 = (point_1.x, point_1.y)
p2 = (point_2.x, point_2.y)
p3 = (point_3.x, point_3.y)
point = [first_point(p1, p2, p3) for _ in range(1)]
e1, e2 = zip(*point)
#plt.scatter(e1, e2, s=1)


if The_Sierpinski_Triangle:
    def distance(t1, t2):
        return math.sqrt((t1[0] - t2[0])**2 + (t1[1] - t2[1])**2)

    distance(point[0], random.choice((point_1.coord(), point_2.coord(), point_3.coord()))) / 2

    def middle_point(t1, t2):
        x = (t1[0] + t2[0])/2
        y = (t1[1] + t2[1])/2
        return list(np.append(x, y))


    num_points_ann = ax.text(15, 32, 'number of points = 0')

    # start point
    random_eck_point_0 = random.choice((point_1.coord(), point_2.coord(), point_3.coord()))
    x0 = middle_point(point[0], random_eck_point_0)[0]
    y0 = middle_point(point[0], random_eck_point_0)[1]
    xi, yi = [], []
    xi.append(x0)
    yi.append(y0)

    n_frames = num_points

    def animate(j):
        global n_frames,num_points_ann

        ax.collections.clear()

        # the other points
        random_eck_point_i = random.choice((point_1.coord(), point_2.coord(), point_3.coord()))
        x = middle_point((xi[j - 1], yi[j - 1]), random_eck_point_i)[0]
        xi .append(x)

        y = middle_point((xi[j - 1], yi[j - 1]), random_eck_point_i)[1]
        yi .append(y)
        plt.scatter(xi, yi, s=2, c='#1f77b4')

        num_points_ann.set_text('number of points = {:} '.format(j))
    anim = FuncAnimation(fig, animate, frames=n_frames, interval=1, blit=False, repeat=False)
    #anim.save('C:/Users/Mem/Desktop/Studium/Vertiefungsmodul/Animationen/The_Sierpinski_Triangle.gif', writer='imagemagick', fps=60)
    #anim.save('/home/soeren/Animations/The_Sierpinski_Triangle.gif', writer='imagemagick', fps=60)
    # plt.close()
    # Image(url='C:/Users/Mem/Desktop/Studium/Vertiefungsmodul/Animationen/TDOA.gif')

    plt.show()

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from matplotlib.animation import FuncAnimation

# Define the centers of the spheres
n = 3  # or any other number of spheres
centers = np.random.uniform(-5, 5, size=(n, 3))

# Define the figure and 3D axes
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

# Define initial radii and increase rate
radii = np.ones(n)
increase_rate = 0.02


# Define a function to animate the intersection of the spheres
def animate(i):
    global radii
    # Define the angle for the animation
    angle = i * np.pi / 180

    # Increase radii
    radii += increase_rate

    # Calculate the intersection of the spheres
    points = []
    for j in range(n):
        p = centers[j] + radii[j] * np.array([np.sin(angle + j * 2 * np.pi / n), np.cos(angle + j * 2 * np.pi / n), 0])
        points.append(p)
    x, y, z = intersection_of_n_spheres(points, radii)

    # Clear the plot and plot the spheres and intersection
    ax.clear()
    ax.set_xlim([-10, 10])
    ax.set_ylim([-10, 10])
    ax.set_zlim([-10, 10])
    for j in range(n):
        ax.scatter(*centers[j], s=radii[j] ** 2)
    ax.plot(x, y, z, linewidth=radii[0])


# Define a function to calculate the intersection of n spheres
def intersection_of_n_spheres(points, radii):
    n = len(points)
    A = np.zeros((n - 1, 3))
    B = np.zeros(n - 1)
    for i in range(1, n):
        A[i - 1] = 2 * (points[i] - points[0])
        B[i - 1] = radii[0] ** 2 - radii[i] ** 2 - np.dot(points[0], points[0]) + np.dot(points[i], points[i])
    x, residuals, rank, s = np.linalg.lstsq(A, B, rcond=None)
    center = points[0] + x
    radius = np.sqrt(np.dot(center, center) - radii[0] ** 2)
    u, v = np.mgrid[0:2 * np.pi:20j, 0:np.pi:10j]
    x = center[0] + radius * np.cos(u) * np.sin(v)
    y = center[1] + radius * np.sin(u) * np.sin(v)
    z = center[2] + radius * np.cos(v)
    return x.flatten(), y.flatten(), z.flatten()


# Animate the intersection of the spheres
anim = FuncAnimation(fig, animate, frames=360, interval=20)
plt.show()



