import matplotlib.pyplot as plt
import matplotlib.tri
from matplotlib import cm
import numpy as np
import random
import sympy as sy
import math
from trilateration import sphereCircle, Trilateration_3D
from matplotlib.animation import FuncAnimation

The_Sierpinski_Triangle = True
length = 30

fig = plt.figure()
ax = fig.add_subplot()
max_width = max(0, length)
ax.set_ylim((0, max_width))
ax.set_xlim((0, max_width))
#ax.plot((-max_width + 1, max_width - 1), (0, 0), (0, 0), 'r', label='x-axis')
#ax.plot((0, 0), (-max_width + 1, max_width - 1), (0, 0), 'k', label='y-axis')

class Points:
    def __init__(self, x, y, color):
        self.x = x
        self.y = y
        self.color = color

    def coord(self):
        return self.x, self.y
    def plot_points(self):
        plot = plt.plot(self.x, self.y, marker=".", color=self.color)
        return plot

p =  length
point_1 = Points(1,1, "red")
point_2 = Points(p-1,1, "red")
point_3 = Points(p/2, p-1, "red")
point_1.plot_points()
point_2.plot_points()
point_3.plot_points()

num_points = np.array(range(1, 2300))

a0 = p-1  # upper bound
b0 = 1    # lower bound

#first_point = ((np.random.rand(num_points, 2)) * (b-a)) + a

def first_point(p1, p2, p3):
    """
    Random first point on the triangle with vertices p1, p2 and p3.
    """
    x, y = sorted([random.random(), random.random()])
    s, t, u = x, y - x, 1 - y
    return (s * p1[0] + t * p2[0] + u * p3[0],
            s * p1[1] + t * p2[1] + u * p3[1])
p1 = (point_1.x, point_1.y)
p2 = (point_2.x, point_2.y)
p3 = (point_3.x, point_3.y)
point = [first_point(p1, p2, p3) for _ in range(1)]
e1, e2 = zip(*point)
#plt.scatter(e1, e2, s=1)


if The_Sierpinski_Triangle:
    def distance(t1, t2):
        return math.sqrt((t1[0] - t2[0])**2 + (t1[1] - t2[1])**2)

    distance(point[0], random.choice((point_1.coord(), point_2.coord(), point_3.coord()))) / 2

    def middle_point(t1, t2):
        x = (t1[0] + t2[0])/2
        y = (t1[1] + t2[1])/2
        return list(np.append(x, y))


    num_points_ann = ax.text(15, 32, 'number of points = 0')

    # start point
    random_eck_point_0 = random.choice((point_1.coord(), point_2.coord(), point_3.coord()))
    x0 = middle_point(point[0], random_eck_point_0)[0]
    y0 = middle_point(point[0], random_eck_point_0)[1]
    xi, yi = [], []
    xi.append(x0)
    yi.append(y0)

    n_frames = num_points

    def animate(j):
        global n_frames,num_points_ann

        ax.collections.clear()

        # the other points
        random_eck_point_i = random.choice((point_1.coord(), point_2.coord(), point_3.coord()))
        x = middle_point((xi[j - 1], yi[j - 1]), random_eck_point_i)[0]
        xi .append(x)

        y = middle_point((xi[j - 1], yi[j - 1]), random_eck_point_i)[1]
        yi .append(y)
        plt.scatter(xi, yi, s=2, c='#1f77b4')

        num_points_ann.set_text('number of points = {:} '.format(j))
    anim = FuncAnimation(fig, animate, frames=n_frames, interval=1, blit=False, repeat=False)
    #anim.save('C:/Users/Mem/Desktop/Studium/Vertiefungsmodul/Animationen/The_Sierpinski_Triangle.gif', writer='imagemagick', fps=60)
    #anim.save('/home/soeren/Animations/The_Sierpinski_Triangle.gif', writer='imagemagick', fps=60)
    # plt.close()
    # Image(url='C:/Users/Mem/Desktop/Studium/Vertiefungsmodul/Animationen/TDOA.gif')

    plt.show()


class Kugeln:
    def __init__(self, radius, x, y, z):
        self.radius = radius
        self.x = x
        self.y = y
        self.z = z

    def coordinaten(self, phi, theta):
        X = self.x + self.radius * np.sin(phi) * np.cos(theta)
        Y = self.y + self.radius * np.sin(phi) * np.sin(theta)
        Z = self.z + self.radius * np.cos(phi)
        return X, Y, Z


# create n instances of the Kugeln class
n = 3
kugeln = []
for i in range(n):
    kugeln.append(Kugeln(radius=1, x=i, y=i, z=i))

# set up the plot
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.set_xlim([-3, 3])
ax.set_ylim([-3, 3])
ax.set_zlim([-3, 3])

# create a list of phi and theta values for the circles
phi_vals = np.linspace(0, np.pi, 50)
theta_vals = np.linspace(0, 2 * np.pi, 50)

# initialize a list of circle plots
circle_plots = []


# animation function
def animate(i):
    # clear the previous frame
    ax.cla()
    ax.set_xlim([-3, 3])
    ax.set_ylim([-3, 3])
    ax.set_zlim([-3, 3])

    # iterate over all pairs of spheres
    for j in range(n):
        for k in range(j + 1, n):
            # calculate the intersection of the spheres
            x1, y1, z1 = kugeln[j].coordinaten(phi_vals, theta_vals)
            x2, y2, z2 = kugeln[k].coordinaten(phi_vals, theta_vals)
            d = np.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2 + (z1 - z2) ** 2)
            x, y, z = 0.5 * (x1 + x2), 0.5 * (y1 + y2), 0.5 * (z1 + z2)
            if (d <= kugeln[j].radius + kugeln[k].radius).all():
                # plot the circle if the spheres intersect
                circle_plots.append(ax.plot(x, y, z, 'bo')[0])

    return circle_plots


# create the animation
ani = FuncAnimation(fig, animate, frames=30, interval=1, blit=True)

# display the animation
plt.show()

